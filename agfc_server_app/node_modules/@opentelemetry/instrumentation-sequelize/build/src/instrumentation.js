"use strict";
/*
 * Copyright The OpenTelemetry Authors, Aspecto
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequelizeInstrumentation = void 0;
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
/** @knipignore */
const version_1 = require("./version");
const utils_1 = require("./utils");
const instrumentation_1 = require("@opentelemetry/instrumentation");
class SequelizeInstrumentation extends instrumentation_1.InstrumentationBase {
    static component = 'sequelize';
    static supportedVersions = '>=6 <7';
    constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const unpatchConnectionManager = (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports?.ConnectionManager?.prototype?.getConnection)) {
                this._unwrap(moduleExports.ConnectionManager.prototype, 'getConnection');
            }
            return moduleExports;
        };
        const connectionManagerInstrumentation = new instrumentation_1.InstrumentationNodeModuleFile('sequelize/lib/dialects/abstract/connection-manager.js', [SequelizeInstrumentation.supportedVersions], moduleExports => {
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            unpatchConnectionManager(moduleExports);
            this._wrap(moduleExports.ConnectionManager.prototype, 'getConnection', this._getConnectionPatch());
            return moduleExports;
        }, unpatchConnectionManager);
        const unpatch = (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.Sequelize.prototype.query)) {
                this._unwrap(moduleExports.Sequelize.prototype, 'query');
            }
        };
        const module = new instrumentation_1.InstrumentationNodeModuleDefinition(SequelizeInstrumentation.component, [SequelizeInstrumentation.supportedVersions], moduleExports => {
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            unpatch(moduleExports);
            this._wrap(moduleExports.Sequelize.prototype, 'query', this._createQueryPatch());
            return moduleExports;
        }, unpatch, [connectionManagerInstrumentation]);
        return module;
    }
    // run getConnection with suppressTracing, as it might call internally to `databaseVersion` function
    // which calls `query` and create internal span which we don't need to instrument
    _getConnectionPatch() {
        return (original) => {
            return function (...args) {
                return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => original.apply(this, args));
            };
        };
    }
    _createQueryPatch() {
        const self = this;
        return (original) => {
            return function query(...args) {
                if (self.getConfig().ignoreOrphanedSpans &&
                    !api_1.trace.getSpan(api_1.context.active())) {
                    return original.apply(this, args);
                }
                const sqlOrQuery = args[0];
                const extractStatement = (sql) => {
                    if (typeof sql === 'string')
                        return sql;
                    return sql?.query || '';
                };
                const statement = extractStatement(args[0]).trim();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const option = args[1];
                let operation = option?.type;
                if (!operation)
                    operation = statement.split(' ')[0];
                const sequelizeInstance = this;
                const config = sequelizeInstance?.config;
                let tableName = option?.instance?.constructor?.tableName;
                if (!tableName) {
                    if (Array.isArray(option?.tableNames) && option.tableNames.length > 0)
                        tableName = option?.tableNames.sort().join(',');
                    else
                        tableName = (0, utils_1.extractTableFromQuery)(statement);
                }
                const attributes = {
                    [semantic_conventions_1.ATTR_DB_SYSTEM_NAME]: sequelizeInstance.getDialect(),
                    [semantic_conventions_1.ATTR_DB_NAMESPACE]: config?.database,
                    [semantic_conventions_1.ATTR_DB_OPERATION_NAME]: operation,
                    [semantic_conventions_1.ATTR_DB_QUERY_TEXT]: statement,
                    [semantic_conventions_1.ATTR_DB_COLLECTION_NAME]: tableName,
                    [semantic_conventions_1.ATTR_SERVER_ADDRESS]: config?.host,
                    [semantic_conventions_1.ATTR_SERVER_PORT]: config?.port ? Number(config?.port) : undefined,
                    [semantic_conventions_1.ATTR_NETWORK_TRANSPORT]: self._getNetTransport(config?.protocol),
                };
                const newSpan = self.tracer.startSpan(`Sequelize ${operation}`, {
                    kind: api_1.SpanKind.CLIENT,
                    attributes,
                });
                const activeContextWithSpan = api_1.trace.setSpan(api_1.context.active(), newSpan);
                const hook = self.getConfig().queryHook;
                if (hook !== undefined && sqlOrQuery !== undefined) {
                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => hook(newSpan, { sql: sqlOrQuery, option }), e => {
                        if (e)
                            api_1.diag.error('sequelize instrumentation: queryHook error', e);
                    }, true);
                }
                return (api_1.context
                    .with(self.getConfig().suppressInternalInstrumentation
                    ? (0, core_1.suppressTracing)(activeContextWithSpan)
                    : activeContextWithSpan, () => original.apply(this, args))
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    .then((response) => {
                    const responseHook = self.getConfig().responseHook;
                    if (responseHook !== undefined) {
                        (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(newSpan, response), e => {
                            if (e)
                                api_1.diag.error('sequelize instrumentation: responseHook error', e);
                        }, true);
                    }
                    return response;
                })
                    .catch((err) => {
                    newSpan.setStatus({
                        code: api_1.SpanStatusCode.ERROR,
                        message: err.message,
                    });
                    throw err;
                })
                    .finally(() => {
                    newSpan.end();
                }));
            };
        };
    }
    _getNetTransport(protocol) {
        switch (protocol) {
            case 'tcp':
                return semantic_conventions_1.NETWORK_TRANSPORT_VALUE_TCP;
            default:
                return undefined;
        }
    }
}
exports.SequelizeInstrumentation = SequelizeInstrumentation;
//# sourceMappingURL=instrumentation.js.map